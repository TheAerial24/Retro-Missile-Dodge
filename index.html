<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Plane Dodging Missiles (8-bit)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<style>
body {
  margin: 0;
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  overflow: hidden;
}
canvas {
  image-rendering: pixelated;
  border: 4px solid #222;
  background: #222;
  box-shadow: 0 0 32px #111;
}
#gameOver {
  position: absolute;
  top: 36%;
  left: 0; right: 0;
  color: #ff4444;
  font-family: monospace;
  font-size: 1.6em;
  text-align: center;
  text-shadow: 2px 2px #000;
  z-index: 10;
  display: none;
}
#score {
  position: absolute;
  top: 8px;
  left: 12px;
  color: #fff;
  font-family: monospace;
  font-size: 14px;
  text-shadow: 1px 1px #000;
  z-index: 10;
}
#restartBtn {
  margin-top: 8px;
  padding: 6px 12px;
  font-family: monospace;
  font-size: 14px;
  background: #222;
  color: #fff;
  border: 2px solid #555;
  cursor: pointer;
}
#restartBtn:hover {
  background: #333;
  border-color: #888;
}
</style>
</head>
<body>
<div id="gameOver">
  GAME OVER<br>
  <small id="finalScore"></small><br>
  <button id="restartBtn">Restart</button>
</div>
<div id="score"></div>
<canvas id="game" width="320" height="480"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// 8-bit palette
const COLORS = {
  plane: ['#e0e0e0','#0077ff','#ff0000'],
  missile: ['#ff2222','#cccccc','#222222'],
  bullet: '#ffff88',
  bg1: '#1e1e1e',
  bg2: '#393939',
  ammoFull: '#55ff55',
  ammoEmpty: '#333333'
};

let gameOver = false;
let frame = 0;
let score = 0;

// Ammo system
const maxAmmo = 75;
let ammo = maxAmmo;
let reloading = false;
let reloadTime = 3000; // 3 seconds in ms
let lastReload = 0;

// Plane
const plane = {
  x: W/2, y: H-60, w: 24, h: 20,
  speed: 3.8,
  vx: 0,
  angle: 0,
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillStyle = COLORS.plane[0];
    ctx.fillRect(-4, -8, 8, 16);
    ctx.fillStyle = COLORS.plane[1];
    ctx.fillRect(-12, 2, 24, 4);
    ctx.fillStyle = COLORS.plane[2];
    ctx.fillRect(-2, -14, 4, 6);
    ctx.restore();
  }
};

// Bullets
const bullets = [];
let bulletCooldown = 0;
const bulletCooldownMax = 12;

function shoot() {
  if (bulletCooldown <= 0 && !gameOver && ammo > 0 && !reloading) {
    bullets.push({
      x: plane.x,
      y: plane.y - 14,
      vx: 0,
      vy: -6.5,
      w: 2,
      h: 6,
      draw() {
        ctx.fillStyle = COLORS.bullet;
        ctx.fillRect(this.x - this.w/2, this.y - this.h/2, this.w, this.h);
      }
    });
    bulletCooldown = bulletCooldownMax;
    ammo--;
    if(ammo === 0){
      reloading = true;
      lastReload = performance.now();
    }
  }
}

// Missiles
const missiles = [];
function spawnMissile() {
  const side = Math.random() < 0.5 ? 'left' : 'right';
  let m = { w: 8, h: 20 };

  if (side === 'left') {
    m.x = -30;
    m.y = 20 + Math.random() * (H/2 - 40);
    m.vx = 1.8 + Math.random() * 0.8;
    m.vy = (Math.random() - 0.2) * 0.8;
  } else { 
    m.x = W + 30;
    m.y = 20 + Math.random() * (H/2 - 40); 
    m.vx = -1.8 - Math.random() * 0.8;
    m.vy = (Math.random() - 0.2) * 0.8;
  }

  m.speed = Math.hypot(m.vx, m.vy);
  m.angle = Math.atan2(m.vy, m.vx);
  m.homingStrength = 0.015 + Math.random() * 0.02;

  m.draw = function() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle + Math.PI/2);
    ctx.fillStyle = COLORS.missile[1];
    ctx.fillRect(-4, -8, 8, 16);
    ctx.fillStyle = COLORS.missile[0];
    ctx.fillRect(-2, -14, 4, 6);
    ctx.fillStyle = COLORS.missile[2];
    ctx.fillRect(-1, -16, 2, 2);
    ctx.restore();
  };

  missiles.push(m);
}

// Particle explosion
const particles = [];
function spawnExplosion(x, y, color='#ffcc44') {
  for (let i = 0; i < 8; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 30 + Math.random() * 20,
      draw() {
        ctx.fillStyle = color;
        ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
      }
    });
  }
}

// Background
let bgOffset = 0;
function drawBackground() {
  for (let y = -32; y < H + 32; y += 32) {
    ctx.fillStyle = ((Math.floor((y + bgOffset) / 32) % 2) === 0) ? COLORS.bg1 : COLORS.bg2;
    ctx.fillRect(0, (y + (bgOffset % 32)), W, 32);
  }
}

// Controls
let left = false, right = false, shooting = false;
window.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft') left = true;
  if (e.key === 'ArrowRight') right = true;
  if (e.code === 'Space') {
    shooting = true;
    shoot();
  }
});
window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft') left = false;
  if (e.key === 'ArrowRight') right = false;
  if (e.code === 'Space') shooting = false;
});

// UI
const scoreEl = document.getElementById('score');
function drawAmmoBar() {
  const barWidth = 200;
  const barHeight = 8;
  const x = (W - barWidth) / 2;
  const y = plane.y + 30;

  // background
  ctx.fillStyle = COLORS.ammoEmpty;
  ctx.fillRect(x, y, barWidth, barHeight);

  // filled ammo
  const filledWidth = (ammo / maxAmmo) * barWidth;
  ctx.fillStyle = COLORS.ammoFull;
  ctx.fillRect(x, y, filledWidth, barHeight);
}

function updateScoreDisplay() {
  scoreEl.textContent = 'Score: ' + score;
}

// Main loop
function loop() {
  if (gameOver) return;
  frame++;

  // handle reload
  if(reloading){
    if(performance.now() - lastReload >= reloadTime){
      ammo = maxAmmo;
      reloading = false;
    }
  }

  bgOffset += 2;
  drawBackground();

  plane.vx = 0;
  if (left) plane.vx = -plane.speed;
  if (right) plane.vx = plane.speed;
  plane.x += plane.vx;
  plane.x = Math.max(20, Math.min(W - 20, plane.x));

  const targetAngle = plane.vx * 0.08; 
  plane.angle += (targetAngle - plane.angle) * 0.12;

  plane.draw();

  if (bulletCooldown > 0) bulletCooldown--;
  if (shooting && bulletCooldown <= 0) shoot();

  const spawnInterval = Math.max(20, 60 - Math.floor(frame / 800));
  if (frame % spawnInterval === 0) spawnMissile();

  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;
    b.draw();
    if (b.y < -20 || b.x < -40 || b.x > W + 40) bullets.splice(i, 1);
  }

  for (let i = missiles.length - 1; i >= 0; i--) {
    const m = missiles[i];

    const dx = plane.x - m.x;
    const dy = plane.y - m.y;
    const dist = Math.hypot(dx, dy);

    if(dist > 6){ // missiles stop homing within 6 pixels
      const desiredAngle = Math.atan2(dy, dx);
      const desiredVx = Math.cos(desiredAngle) * m.speed;
      const desiredVy = Math.sin(desiredAngle) * m.speed;
      m.vx += (desiredVx - m.vx) * m.homingStrength;
      m.vy += (desiredVy - m.vy) * m.homingStrength;
    }

    m.x += m.vx;
    m.y += m.vy;
    m.speed = Math.hypot(m.vx, m.vy);
    m.angle = Math.atan2(m.vy, m.vx);

    m.draw();

    // collision with bullets
    let destroyed = false;
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      const dx2 = b.x - m.x;
      const dy2 = b.y - m.y;
      if (Math.hypot(dx2, dy2) < (Math.max(m.w, m.h)/2 + Math.max(b.w, b.h)/2)) {
        bullets.splice(j, 1);
        missiles.splice(i, 1);
        destroyed = true;
        score += 10;
        updateScoreDisplay();
        spawnExplosion(m.x, m.y, '#ffcc44');
        break;
      }
    }
    if (destroyed) continue;

    // collision with plane
    const dxp = m.x - plane.x;
    const dyp = m.y - plane.y;
    const distp = Math.hypot(dxp, dyp);
    const planeRadius = Math.max(plane.w, plane.h)/2 - 2;
    const missileRadius = Math.max(m.w, m.h)/2 - 1;
    if(distp < planeRadius + missileRadius){
      endGame();
      return;
    }
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life -= 1;
    p.draw();
    if(p.life <= 0) particles.splice(i,1);
  }

  for (let i = missiles.length - 1; i >= 0; i--){
    const m = missiles[i];
    if(m.x < -120 || m.x > W+120 || m.y > H+120 || m.y < -240) missiles.splice(i,1);
  }

  drawAmmoBar();
  requestAnimationFrame(loop);
}

function endGame(){
  gameOver = true;
  document.getElementById('gameOver').style.display = 'block';
  document.getElementById('finalScore').textContent = 'Score: ' + score;
}

// Restart button
document.getElementById('restartBtn').addEventListener('click',()=>{
  gameOver=false;
  frame=0;
  score=0;
  ammo=maxAmmo;
  reloading=false;
  plane.x=W/2;
  plane.y=H-60;
  plane.vx=0;
  plane.angle=0;
  bullets.length=0;
  missiles.length=0;
  particles.length=0;
  document.getElementById('gameOver').style.display='none';
  updateScoreDisplay();
  loop();
});

updateScoreDisplay();
loop();
</script>
</body>
</html>
