<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Triple Flak Defense</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<style>
body {
  margin:0;
  background:#87CEEB;
  display:flex;
  align-items:center;
  justify-content:center;
  height:100vh;
  overflow:hidden;
}
canvas {
  image-rendering: pixelated;
  border:4px solid #222;
  box-shadow:0 0 32px #111;
  background:#87CEEB;
}
</style>
</head>
<body>
<canvas id="game" width="320" height="480"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// Colors
const COLORS = {
  turret: ['#444','#777','#aaa'],
  enemy: ['#555','#888','#aaa'],
  flak: '#333',
  shrapnel: '#ffcc66',
  cloud: '#fff',
  heart: '#ff4444',
  ammo: '#00cc00',
  grass: '#228B22'
};

// Game state
let score = 0, health = 5, maxHealth = 5;
let ammo = 500, maxAmmo = 500, reloadCooldown = 0, reloadTime = 120;
let reloading = false;
let gameOver = false;

// === MULTI-TURRET SYSTEM ===
const turretPositions = [
  { x: W/2, y: H-40, angleOffset: 0 },      
  { x: W/2 - 70, y: H-40, angleOffset: -0.1 }, 
  { x: W/2 + 70, y: H-40, angleOffset: 0.1 }   
];

const turrets = turretPositions.map(pos => ({
  ...pos,
  baseW: 32,
  baseH: 16,
  barrelLength: 20,
  angle: 0,
  draw() {
    ctx.fillStyle = COLORS.turret[0];
    ctx.fillRect(this.x - this.baseW/2, this.y - this.baseH/2, this.baseW, this.baseH);
    ctx.save();
    ctx.translate(this.x, this.y - this.baseH/2);
    ctx.rotate(this.angle + this.angleOffset);
    ctx.fillStyle = COLORS.turret[2];
    ctx.fillRect(-2, -this.barrelLength, 4, this.barrelLength);
    ctx.restore();
  }
}));

// Projectiles
const flakShells = [];
const shrapnelPieces = [];
const particles = [];
let bulletCooldown = 0;
const bulletCooldownMax = 15;

function shoot() {
  if (bulletCooldown <= 0 && ammo > 0 && !reloading && !gameOver) {
    turrets.forEach(t => {
      const vx = Math.sin(t.angle + t.angleOffset) * 5.5;
      const vy = -Math.cos(t.angle + t.angleOffset) * 5.5;
      flakShells.push({
        x: t.x,
        y: t.y - t.baseH/2 - 4,
        vx, vy,
        life: 150,
        draw() {
          ctx.fillStyle = COLORS.flak;
          ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
        }
      });
    });
    bulletCooldown = bulletCooldownMax;
    ammo--;
    if (ammo <= 0) { reloading = true; reloadCooldown = 0; }
  }
}

// Enemies
const enemies = [];
function spawnEnemy() {
  let e = { w: 24, h: 20 };
  e.x = 20 + Math.random() * (W - 40);
  e.y = -20;
  e.vx = (Math.random() - 0.5) * 1.2;
  e.vy = 2 + Math.random() * 1.5;
  e.speed = Math.hypot(e.vx, e.vy);
  e.angle = Math.atan2(e.vy, e.vx);
  e.homingStrength = 0.02 + Math.random() * 0.02;
  e.draw = function() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle + Math.PI/2);
    ctx.fillStyle = COLORS.enemy[0];
    ctx.fillRect(-4, -8, 8, 16);
    ctx.fillStyle = COLORS.enemy[1];
    ctx.fillRect(-12, 2, 24, 4);
    ctx.fillStyle = COLORS.enemy[2];
    ctx.fillRect(-2, -14, 4, 6);
    ctx.restore();
  };
  enemies.push(e);
}

// Explosion + Shrapnel
function spawnFlakExplosion(x, y) {
  // smoke particles
  for (let i=0; i<10; i++) {
    const a = Math.random()*Math.PI*2;
    const s = 0.5 + Math.random()*1.2;
    particles.push({x, y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:30+Math.random()*20, color:'rgba(200,200,200,0.6)'});
  }
  // shrapnel
  const count = 8 + Math.floor(Math.random()*4);
  for (let i=0;i<count;i++){
    const ang = (i/count)*Math.PI*2 + Math.random()*0.2;
    const spd = 2.5 + Math.random()*1.5;
    shrapnelPieces.push({
      x, y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd,
      life:40+Math.random()*10,
      draw(){
        ctx.fillStyle = COLORS.shrapnel;
        ctx.fillRect(this.x-1,this.y-1,2,2);
      }
    });
  }
}

// Clouds
const clouds = [];
for (let i=0;i<15;i++) {
  clouds.push({ x:Math.random()*W, y:Math.random()*H/2, w:40+Math.random()*30, h:20+Math.random()*10 });
}
function drawBackground() {
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, '#6EC6FF');
  gradient.addColorStop(1, '#87CEEB');
  ctx.fillStyle = gradient;
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = COLORS.cloud;
  clouds.forEach(c=>{
    c.y += 0.3;
    if(c.y > H) c.y = -c.h;
    ctx.fillRect(c.x, c.y, c.w, c.h);
  });
  ctx.fillStyle = COLORS.grass;
  ctx.fillRect(0, H-40, W, 40);
}

// Controls
let left=false,right=false,shooting=false;
window.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft') left=true;
  if(e.key==='ArrowRight') right=true;
  if(e.code==='Space'){ if(gameOver) restartGame(); shooting=true; shoot(); }
});
window.addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft') left=false;
  if(e.key==='ArrowRight') right=false;
  if(e.code==='Space') shooting=false;
});

// HUD
function drawHUD(){
  ctx.fillStyle='#000';
  ctx.font='14px monospace';
  ctx.textAlign='left';
  ctx.fillText('Score: '+score,10,16);
  for(let i=0;i<maxHealth;i++){
    const x=10+i*14,y=30;
    ctx.fillStyle=(i<health)?COLORS.heart:'#555';
    ctx.fillRect(x,y,12,12);
  }
  const barWidth=120,barHeight=8;
  const x=W/2-barWidth/2,y=H-30;
  ctx.fillStyle='#555';ctx.fillRect(x,y,barWidth,barHeight);
  ctx.fillStyle=COLORS.ammo;ctx.fillRect(x,y,barWidth*(ammo/maxAmmo),barHeight);
  ctx.fillStyle='#000';ctx.textAlign='right';
  ctx.fillText('High: '+(parseInt(localStorage.getItem('highScore'))||0),W-10,16);
}

function drawGameOver(){
  ctx.fillStyle='rgba(0,0,0,0.6)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#fff';
  ctx.font='20px monospace';
  ctx.textAlign='center';
  ctx.fillText('GAME OVER',W/2,H/2-20);
  ctx.font='14px monospace';
  ctx.fillText('Score: '+score,W/2,H/2+5);
  ctx.fillText('Press SPACE to Restart',W/2,H/2+30);
}

function restartGame(){
  score=0;health=5;ammo=maxAmmo;
  enemies.length=0;flakShells.length=0;shrapnelPieces.length=0;particles.length=0;
  gameOver=false;
}

// === Main Loop ===
let frame=0;
function loop(){
  frame++;
  drawBackground();

  if(!gameOver){
    // Turrets
    turrets.forEach(t=>{
      if(left) t.angle-=0.05;
      if(right) t.angle+=0.05;
      t.angle=Math.max(-Math.PI/4,Math.min(Math.PI/4,t.angle));
      t.draw();
    });

    if(bulletCooldown>0) bulletCooldown--;
    if(shooting && bulletCooldown<=0) shoot();

    if(reloading){
      reloadCooldown++;
      if(reloadCooldown>=reloadTime){ammo=maxAmmo;reloading=false;}
    }

    if(frame%60===0) spawnEnemy();

    // Flak shells
    for(let i=flakShells.length-1;i>=0;i--){
      const f=flakShells[i];
      f.x+=f.vx; f.y+=f.vy; f.life--;
      f.draw();
      // proximity detonation
      let detonate=false;
      for(const e of enemies){
        const dist=Math.hypot(f.x-e.x,f.y-e.y);
        if(dist<40){detonate=true;break;}
      }
      if(f.life<=0 || detonate){
        spawnFlakExplosion(f.x,f.y);
        flakShells.splice(i,1);
      } else if(f.y<-20) flakShells.splice(i,1);
    }

    // Shrapnel
    for(let i=shrapnelPieces.length-1;i>=0;i--){
      const s=shrapnelPieces[i];
      s.x+=s.vx; s.y+=s.vy; s.vy+=0.03;
      s.life--; s.draw();
      if(s.life<=0) shrapnelPieces.splice(i,1);
    }

    // Enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      const dx=W/2 - e.x;
      const dy=(H-40 - e.y);
      const dist=Math.hypot(dx,dy);
      if(dist>40){
        const desiredAngle=Math.atan2(dy,dx);
        const desiredVx=Math.cos(desiredAngle)*e.speed;
        const desiredVy=Math.sin(desiredAngle)*e.speed;
        e.vx+=(desiredVx-e.vx)*e.homingStrength;
        e.vy+=(desiredVy-e.vy)*e.homingStrength;
      }
      e.x+=e.vx;e.y+=e.vy;
      e.speed=Math.hypot(e.vx,e.vy);
      e.angle=Math.atan2(e.vy,e.vx);
      e.draw();

      // Collision with shrapnel
      for(let j=shrapnelPieces.length-1;j>=0;j--){
        const s=shrapnelPieces[j];
        if(Math.hypot(s.x-e.x,s.y-e.y)<10){
          shrapnelPieces.splice(j,1);
          enemies.splice(i,1);
          score+=10;
          spawnFlakExplosion(e.x,e.y);
          break;
        }
      }

      // Collision with base
      for(const t of turrets){
        const d=Math.hypot(t.x-e.x,t.y-e.y);
        if(d<25){
          spawnFlakExplosion(e.x,e.y);
          enemies.splice(i,1);
          health--;
          if(health<=0){
            const high=parseInt(localStorage.getItem('highScore'))||0;
            if(score>high)localStorage.setItem('highScore',score);
            gameOver=true;
          }
          break;
        }
      }

      // Plane passed ground
      if(e.y>H-60){
        spawnFlakExplosion(e.x,e.y);
        enemies.splice(i,1);
        health--;
        if(health<=0){
          const high=parseInt(localStorage.getItem('highScore'))||0;
          if(score>high)localStorage.setItem('highScore',score);
          gameOver=true;
        }
      }
    }

    // Particles
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.x+=p.vx; p.y+=p.vy; p.vy+=0.02; p.life--;
      ctx.fillStyle=p.color;
      ctx.fillRect(p.x-1,p.y-1,2,2);
      if(p.life<=0) particles.splice(i,1);
    }

    drawHUD();
  } else drawGameOver();

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
