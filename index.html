<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Triple Flak Defense â€” Part 3 (Waves)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<style>
  body{margin:0;background:#87CEEB;display:flex;align-items:center;justify-content:center;height:100vh;overflow:hidden}
  canvas{image-rendering:pixelated;border:4px solid #222;box-shadow:0 0 32px #111;background:#87CEEB}
</style>
</head>
<body>
<canvas id="game" width="320" height="480"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// Colors
const COLORS = {
  turret: ['#444','#777','#aaa'],
  flak: '#333',
  shrapnel: '#ffcc66',
  bomber: ['#3b3b3b','#a0a0a0','#222'],
  bomb: '#1a1a1a',
  cloud: '#fff',
  heart: '#ff4444',
  ammo: '#00cc00',
  grass: '#228B22',
  waveText: '#ff2222'
};

// --- Game State / Phases ---
let phase = 'intro';          // 'intro' | 'wavebreak' | 'playing' | 'gameover'
let score = 0, health = 5, maxHealth = 5;
let ammo = 500, maxAmmo = 500, reloadCooldown = 0, reloadTime = 120;
let reloading = false;
let frame = 0;
let lastFlyover = 0;

// Wave system
let currentWave = 1;
let nextBreakScore = 5000;     // trigger at 5k, 10k, 15k, ...
const BREAK_DURATION_FRAMES = 300; // 5 seconds @ 60fps
let breakStartFrame = 0;

// Turrets (triple)
const turretPositions = [
  { x: W/2,     y: H-40, angleOffset: 0   },   // center
  { x: W/2 -70, y: H-40, angleOffset: -0.1},   // left
  { x: W/2 +70, y: H-40, angleOffset: 0.1 }    // right
];

const turrets = turretPositions.map(pos => ({
  ...pos,
  baseW: 32, baseH: 16, barrelLength: 20, angle: 0,
  draw(){
    ctx.fillStyle = COLORS.turret[0];
    ctx.fillRect(this.x - this.baseW/2, this.y - this.baseH/2, this.baseW, this.baseH);
    ctx.save();
    ctx.translate(this.x, this.y - this.baseH/2);
    ctx.rotate(this.angle + this.angleOffset);
    ctx.fillStyle = COLORS.turret[2];
    ctx.fillRect(-2, -this.barrelLength, 4, this.barrelLength);
    ctx.restore();
  }
}));

// Projectiles / FX
const flakShells = [];
const shrapnelPieces = [];
const particles = [];
let bulletCooldown = 0;
const bulletCooldownMax = 15;

// Bombers & Bombs
const introBombers = [];   // opening formation
const bombers = [];        // periodic flyovers
const bombs = [];

// Clouds
const clouds = [];
for (let i=0;i<15;i++){
  clouds.push({x:Math.random()*W,y:Math.random()*H/2,w:40+Math.random()*30,h:20+Math.random()*10});
}

// ---------- Drawing ----------
function drawBackground(){
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#6EC6FF'); g.addColorStop(1,'#87CEEB');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  ctx.fillStyle = COLORS.cloud;
  clouds.forEach(c=>{
    c.y += 0.25; if(c.y>H) c.y = -c.h;
    ctx.fillRect(c.x,c.y,c.w,c.h);
  });

  // Ground
  ctx.fillStyle = COLORS.grass;
  ctx.fillRect(0,H-40,W,40);
}

function drawHUD(){
  ctx.fillStyle='#000'; ctx.font='14px monospace'; ctx.textAlign='left';
  ctx.fillText('Score: '+score,10,16);
  // Hearts
  for(let i=0;i<maxHealth;i++){
    const x=10+i*14,y=30;
    ctx.fillStyle=(i<health)?COLORS.heart:'#555';
    ctx.fillRect(x,y,12,12);
  }
  // Ammo bar
  const barWidth=120,barHeight=8;
  const x=W/2-barWidth/2,y=H-30;
  ctx.fillStyle='#555'; ctx.fillRect(x,y,barWidth,barHeight);
  ctx.fillStyle=COLORS.ammo; ctx.fillRect(x,y,barWidth*(ammo/maxAmmo),barHeight);

  // Highscore
  ctx.fillStyle='#000'; ctx.textAlign='right';
  ctx.fillText('High: '+(parseInt(localStorage.getItem('highScore'))||0), W-10,16);
}

function drawGameOver(){
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#fff'; ctx.textAlign='center';
  ctx.font='20px monospace'; ctx.fillText('GAME OVER', W/2, H/2-20);
  ctx.font='14px monospace';
  ctx.fillText('Score: '+score, W/2, H/2+5);
  ctx.fillText('Press SPACE to Restart', W/2, H/2+30);
}

function drawTitle(){
  ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#fff'; ctx.textAlign='center';
  ctx.font='16px monospace'; ctx.fillText('B-17 FORMATION INBOUND...', W/2, 60);
  ctx.font='12px monospace'; ctx.fillText('Stand by...', W/2, 80);
}

function roman(n){
  const map = [
    [1000,'M'],[900,'CM'],[500,'D'],[400,'CD'],
    [100,'C'],[90,'XC'],[50,'L'],[40,'XL'],
    [10,'X'],[9,'IX'],[5,'V'],[4,'IV'],[1,'I']
  ];
  let s='';
  for(const [v,r] of map){ while(n>=v){ s+=r; n-=v; } }
  return s;
}

function drawWaveBanner(num, elapsedFrames){
  // Pulsing scale + alpha over time
  const t = elapsedFrames / 60; // seconds-ish
  const pulse = 0.08 * Math.sin(elapsedFrames * 0.3);
  const alpha = 0.85 + 0.15*Math.sin(elapsedFrames * 0.6);
  ctx.save();
  ctx.globalAlpha = Math.max(0.3, Math.min(1, alpha));
  ctx.translate(W/2, H/2 - 60);
  ctx.scale(1+pulse, 1+pulse);
  ctx.fillStyle = COLORS.waveText;
  ctx.textAlign = 'center';
  ctx.font = 'bold 26px monospace';
  ctx.fillText('WAVE ' + roman(num), 0, 0);
  ctx.restore();
}

// ---------- Entities ----------
function shoot(){
  if (bulletCooldown<=0 && ammo>0 && !reloading && phase==='playing'){
    turrets.forEach(t=>{
      const vx = Math.sin(t.angle + t.angleOffset) * 5.5;
      const vy = -Math.cos(t.angle + t.angleOffset) * 5.5;
      flakShells.push({x:t.x,y:t.y - t.baseH/2 - 4, vx,vy, life:150});
    });
    bulletCooldown = bulletCooldownMax;
    ammo--;
    if (ammo<=0){ reloading=true; reloadCooldown=0; }
  }
}

function spawnFlakExplosion(x,y){
  // smoke
  for(let i=0;i<10;i++){
    const a=Math.random()*Math.PI*2, s=0.5+Math.random()*1.2;
    particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:30+Math.random()*20,color:'rgba(200,200,200,0.6)'});
  }
  // shrapnel
  const count = 8 + Math.floor(Math.random()*4);
  for(let i=0;i<count;i++){
    const ang=(i/count)*Math.PI*2 + Math.random()*0.2;
    const spd=2.4 + Math.random()*1.3;
    shrapnelPieces.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:40+Math.random()*10});
  }
}

// Intro formation
function spawnIntroFormation(){
  const rows = [
    {x:-80, y:35, delay:0},
    {x:-120,y:50, delay:12},
    {x:-160,y:65, delay:24},
    {x:-200,y:80, delay:36},
    {x:-240,y:95, delay:48},
  ];
  introBombers.length = 0;
  rows.forEach(r=>{
    introBombers.push({
      x:r.x, y:r.y, vx:1.2, w:46, h:16, delay:r.delay, active:false, hp:999, intro:true
    });
  });
}

function spawnFlyover(){
  const fromLeft = Math.random()<0.5;
  bombers.push({
    x: fromLeft ? -60 : W+60,
    y: 40 + Math.random()*25,
    vx: fromLeft ? 1.6 : -1.6,
    w: 46, h: 16, hp:1
  });
}

function spawnBomb(x){
  bombs.push({x: Math.max(10,Math.min(W-10,x)), y: -10, vy: 2.0 + Math.random()*1.2, r:5});
}

function spawnBombPattern(){
  const type = Math.floor(Math.random()*3); // 0 scatter, 1 burst, 2 line
  if (type===0){
    const n=2+Math.floor(Math.random()*4);
    for(let i=0;i<n;i++) spawnBomb(Math.random()*W);
  } else if (type===1){
    const center = 20 + Math.random()*(W-40);
    for(let i=0;i<5;i++) spawnBomb(center + (Math.random()-0.5)*30);
  } else {
    const start = Math.random()<0.5 ? 20 : W-20;
    const step = (start< W/2) ? 20 : -20;
    for(let i=0;i<6;i++) spawnBomb(start + i*step);
  }
}

// ---------- Drawing helpers ----------
function drawBomber(b){
  ctx.save();
  ctx.translate(b.x, b.y);
  ctx.fillStyle = COLORS.bomber[0];         // fuselage
  ctx.fillRect(-18,-5,36,10);
  ctx.fillStyle = COLORS.bomber[1];         // nose
  ctx.fillRect(18,-4,8,8);
  ctx.fillStyle = COLORS.bomber[0];         // wings
  ctx.fillRect(-8,-10,16,6);
  ctx.fillRect(-6,4,12,6);
  ctx.fillStyle = COLORS.bomber[2];         // tail
  ctx.fillRect(-22,-6,6,12);
  ctx.restore();
}

function drawBomb(bm){
  ctx.fillStyle = COLORS.bomb;
  ctx.fillRect(bm.x-2,bm.y-4,4,8);
}

// ---------- Controls ----------
let left=false,right=false,shooting=false;
window.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft') left=true;
  if(e.key==='ArrowRight') right=true;
  if(e.code==='Space'){
    if (phase==='gameover'){ restartGame(); return; }
    if (phase==='playing'){ shooting=true; shoot(); }
  }
  if(e.code==='KeyR'){ // Manual reload
    if (!reloading && ammo < maxAmmo && phase!=='gameover'){
      reloading = true; reloadCooldown = 0;
    }
  }
});
window.addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft') left=false;
  if(e.key==='ArrowRight') right=false;
  if(e.code==='Space') shooting=false;
});

// ---------- Wave Flow Helpers ----------
function startWaveBreak(waveNumber){
  currentWave = waveNumber;
  phase = 'wavebreak';
  breakStartFrame = frame;
}

function endWaveBreak(){
  phase = 'playing';
  lastFlyover = frame; // reset bomber timer so we don't insta-spawn during the banner
}

function checkWaveProgress(){
  // Trigger a new break exactly when score meets/exceeds each 5000 step
  if (phase==='playing' && score >= nextBreakScore){
    startWaveBreak(currentWave + 1);
    nextBreakScore += 5000;
  }
}

// ---------- Game Flow ----------
function beginFirstWaveAfterIntro(){
  // After intro, start with Wave I banner for 5s
  startWaveBreak(1);
}

function restartGame(){
  score=0; health=5; ammo=maxAmmo;
  flakShells.length=0; shrapnelPieces.length=0; particles.length=0;
  bombs.length=0; bombers.length=0; introBombers.length=0;
  phase='intro'; frame=0; reloading=false; bulletCooldown=0;
  currentWave = 1; nextBreakScore = 5000; breakStartFrame = 0;
  lastFlyover = 0;
  spawnIntroFormation();
}

// ---------- Init ----------
spawnIntroFormation();

// ---------- Main Loop ----------
function loop(){
  frame++;
  drawBackground();

  // Turrets always draw (rotation only during playing)
  turrets.forEach(t=>{
    if(phase==='playing'){
      if(left) t.angle -= 0.05;
      if(right) t.angle += 0.05;
      t.angle = Math.max(-Math.PI/4, Math.min(Math.PI/4, t.angle));
    }
    t.draw();
  });

  // --- INTRO: formation passes, then Wave I break ---
  if (phase==='intro'){
    drawTitle();
    for (let i=introBombers.length-1;i>=0;i--){
      const b=introBombers[i];
      if (b.delay>0){ b.delay--; continue; }
      b.x += b.vx;
      drawBomber(b);
    }
    const allGone = introBombers.every(b=> b.delay<=0 && b.x > W+80);
    if (allGone){
      // Show a little "Incoming Raid!" for flavor, then wave I
      ctx.fillStyle='#000'; ctx.font='16px monospace'; ctx.textAlign='center';
      ctx.fillText('INCOMING RAID!', W/2, 130);
      if (frame>180) beginFirstWaveAfterIntro();
    }
  }

  // --- WAVE BREAK: show pulsing banner, pause spawns for 5s ---
  if (phase==='wavebreak'){
    const elapsed = frame - breakStartFrame;
    drawWaveBanner(currentWave, elapsed);
    // No spawns during break. You can still rotate/aim/reload.
    if (elapsed >= BREAK_DURATION_FRAMES){
      endWaveBreak(); // start playing after 5s
    }
  }

  // --- PLAYING: normal action ---
  if (phase==='playing'){
    // continuous fire
    if (bulletCooldown>0) bulletCooldown--;
    if (shooting && bulletCooldown<=0) shoot();

    // reload progress
    if (reloading){
      reloadCooldown++;
      if (reloadCooldown>=reloadTime){ ammo=maxAmmo; reloading=false; }
    }

    // periodic bomber flyover every 5s
    if (frame - lastFlyover >= 300){
      spawnFlyover();
      lastFlyover = frame;
    }

    // bomb spawn rhythm
    if (frame % 45 === 0) spawnBombPattern();

    // Flak shells (auto-detonate near bombs or bombers)
    for (let i=flakShells.length-1;i>=0;i--){
      const f=flakShells[i];
      f.x += f.vx; f.y += f.vy; f.life--;
      let detonate=false;
      for (const m of bombs){ if (Math.hypot(f.x-m.x,f.y-m.y) < 40){ detonate=true; break; } }
      if (!detonate){
        for (const b of bombers){ if (Math.hypot(f.x-b.x,f.y-b.y) < 40){ detonate=true; break; } }
      }
      ctx.fillStyle = COLORS.flak; ctx.fillRect(f.x-2,f.y-2,4,4);
      if (f.life<=0 || detonate || f.y<-20) { spawnFlakExplosion(f.x,f.y); flakShells.splice(i,1); }
    }

    // Shrapnel
    for (let i=shrapnelPieces.length-1;i>=0;i--){
      const s=shrapnelPieces[i];
      s.x += s.vx; s.y += s.vy; s.vy += 0.03; s.life--;
      ctx.fillStyle = COLORS.shrapnel; ctx.fillRect(s.x-1,s.y-1,2,2);
      if (s.life<=0) { shrapnelPieces.splice(i,1); continue; }

      // Hit bombs
      for (let j=bombs.length-1;j>=0;j--){
        const m=bombs[j];
        if (Math.hypot(s.x-m.x,s.y-m.y) < 10){
          bombs.splice(j,1);
          score += 10;
          spawnFlakExplosion(m.x,m.y);
          shrapnelPieces.splice(i,1);
          break;
        }
      }
      // Hit bombers
      for (let k=bombers.length-1;k>=0;k--){
        const b=bombers[k];
        if (Math.abs(s.x-b.x)<20 && Math.abs(s.y-b.y)<10){
          b.hp -= 1;
          if (b.hp<=0){
            bombers.splice(k,1);
            score += 100;
            spawnFlakExplosion(b.x,b.y);
            // Check immediately if we crossed a wave threshold with this kill
            checkWaveProgress();
          }
          shrapnelPieces.splice(i,1);
          break;
        }
      }
    }

    // Bombers (flyovers)
    for (let i=bombers.length-1;i>=0;i--){
      const b=bombers[i];
      b.x += b.vx;
      drawBomber(b);
      if (b.x < -80 || b.x > W+80) bombers.splice(i,1);
    }

    // Bombs
    for (let i=bombs.length-1;i>=0;i--){
      const m=bombs[i];
      m.y += m.vy;
      drawBomb(m);

      // Hit ground
      if (m.y > H-40){
        bombs.splice(i,1);
        spawnFlakExplosion(m.x,m.y);
        health--;
        if (health<=0){
          const high=parseInt(localStorage.getItem('highScore'))||0;
          if (score>high) localStorage.setItem('highScore', score);
          phase='gameover';
        }
        continue;
      }
      // Hit turrets
      for (const t of turrets){
        if (Math.hypot(t.x-m.x, t.y-m.y) < 20){
          bombs.splice(i,1);
          spawnFlakExplosion(m.x,m.y);
          health--;
          if (health<=0){
            const high=parseInt(localStorage.getItem('highScore'))||0;
            if (score>high) localStorage.setItem('highScore', score);
            phase='gameover';
          }
          break;
        }
      }
    }

    // After all updates, check score threshold for next wave break
    checkWaveProgress();
  }

  // Particles (smoke/explosions)
  for (let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.02; p.life--;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x-1,p.y-1,2,2);
    if (p.life<=0) particles.splice(i,1);
  }

  // Overlays
  if (phase==='gameover') drawGameOver();
  drawHUD();

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
