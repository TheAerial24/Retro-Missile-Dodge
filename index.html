<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Triple Anti-Air Defense</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<style>
body {
  margin:0;
  background:#87CEEB;
  display:flex;
  align-items:center;
  justify-content:center;
  height:100vh;
  overflow:hidden;
}
canvas {
  image-rendering: pixelated;
  border:4px solid #222;
  box-shadow:0 0 32px #111;
  background:#87CEEB;
}
</style>
</head>
<body>
<canvas id="game" width="320" height="480"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// Colors
const COLORS = {
  turret: ['#444','#777','#aaa'],
  enemy: ['#555','#888','#aaa'],
  bullet: '#ffff88',
  cloud: '#fff',
  heart: '#ff4444',
  ammo: '#00cc00',
  grass: '#228B22'
};

// Game state
let score = 0, health = 5, maxHealth = 5;
let ammo = 500, maxAmmo = 500, reloadCooldown = 0, reloadTime = 120;
let reloading = false;
let gameOver = false;

// === MULTI-TURRET SYSTEM ===
const turretPositions = [
  { x: W/2, y: H-40, angleOffset: 0 },      // center
  { x: W/2 - 70, y: H-40, angleOffset: -0.1 }, // left
  { x: W/2 + 70, y: H-40, angleOffset: 0.1 }   // right
];

const turrets = turretPositions.map(pos => ({
  ...pos,
  baseW: 32,
  baseH: 16,
  barrelLength: 20,
  angle: 0,
  draw() {
    ctx.fillStyle = COLORS.turret[0];
    ctx.fillRect(this.x - this.baseW/2, this.y - this.baseH/2, this.baseW, this.baseH);
    ctx.save();
    ctx.translate(this.x, this.y - this.baseH/2);
    ctx.rotate(this.angle + this.angleOffset);
    ctx.fillStyle = COLORS.turret[2];
    ctx.fillRect(-2, -this.barrelLength, 4, this.barrelLength);
    ctx.restore();
  }
}));

// Bullets
const bullets = [];
let bulletCooldown = 0;
const bulletCooldownMax = 12;
function shoot() {
  if (bulletCooldown <= 0 && ammo > 0 && !reloading && !gameOver) {
    turrets.forEach(t => {
      const vx = Math.sin(t.angle + t.angleOffset) * 6.5;
      const vy = -Math.cos(t.angle + t.angleOffset) * 6.5;
      bullets.push({
        x: t.x,
        y: t.y - t.baseH/2 - 4,
        vx, vy,
        w: 2, h: 6,
        draw() {
          ctx.fillStyle = COLORS.bullet;
          ctx.fillRect(this.x - this.w/2, this.y - this.h/2, this.w, this.h);
        }
      });
    });
    bulletCooldown = bulletCooldownMax;
    ammo--;
    if (ammo <= 0) { reloading = true; reloadCooldown = 0; }
  }
}

// Enemies
const enemies = [];
function spawnEnemy() {
  let e = { w: 24, h: 20 };
  e.x = 20 + Math.random() * (W - 40);
  e.y = -20;
  e.vx = (Math.random() - 0.5) * 1.2;
  e.vy = 2 + Math.random() * 1.5;
  e.speed = Math.hypot(e.vx, e.vy);
  e.angle = Math.atan2(e.vy, e.vx);
  e.homingStrength = 0.02 + Math.random() * 0.02;
  e.draw = function() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle + Math.PI/2);
    ctx.fillStyle = COLORS.enemy[0];
    ctx.fillRect(-4, -8, 8, 16);
    ctx.fillStyle = COLORS.enemy[1];
    ctx.fillRect(-12, 2, 24, 4);
    ctx.fillStyle = COLORS.enemy[2];
    ctx.fillRect(-2, -14, 4, 6);
    ctx.restore();
  };
  enemies.push(e);
}

// Particles
const particles = [];
function spawnExplosion(x, y, color='#ffcc44') {
  for (let i=0;i<8;i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 30 + Math.random() * 20,
      draw() {
        ctx.fillStyle = color;
        ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
      }
    });
  }
}

// Clouds
const clouds = [];
for (let i=0;i<15;i++) {
  clouds.push({ x:Math.random()*W, y:Math.random()*H/2, w:40+Math.random()*30, h:20+Math.random()*10 });
}

function drawBackground() {
  // Sky
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, '#6EC6FF');
  gradient.addColorStop(1, '#87CEEB');
  ctx.fillStyle = gradient;
  ctx.fillRect(0,0,W,H);
  
  // Clouds
  ctx.fillStyle = COLORS.cloud;
  clouds.forEach(c=>{
    c.y += 0.3;
    if(c.y > H) c.y = -c.h;
    ctx.fillRect(c.x, c.y, c.w, c.h);
  });
  
  // Grass ground
  ctx.fillStyle = COLORS.grass;
  ctx.fillRect(0, H-40, W, 40);
}

// Controls
let left = false, right = false, shooting = false;
window.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft') left = true;
  if (e.key === 'ArrowRight') right = true;
  if (e.code === 'Space') {
    if (gameOver) restartGame();
    shooting = true;
    shoot();
  }
});
window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft') left = false;
  if (e.key === 'ArrowRight') right = false;
  if (e.code === 'Space') shooting = false;
});

let frame = 0;

// HUD
function drawHUD() {
  ctx.fillStyle = '#000';
  ctx.font = '14px monospace';
  ctx.textAlign = 'left';
  ctx.fillText('Score: ' + score, 10, 16);

  // Hearts
  for (let i=0;i<maxHealth;i++) {
    const x = 10 + i * 14, y = 30;
    ctx.fillStyle = (i < health) ? COLORS.heart : '#555';
    ctx.fillRect(x, y, 12, 12);
  }

  // Ammo bar
  const barWidth = 120, barHeight = 8;
  const x = W/2 - barWidth/2, y = H - 30;
  ctx.fillStyle = '#555';
  ctx.fillRect(x, y, barWidth, barHeight);
  ctx.fillStyle = COLORS.ammo;
  ctx.fillRect(x, y, barWidth * (ammo / maxAmmo), barHeight);

  // High Score
  ctx.fillStyle = '#000';
  ctx.textAlign = 'right';
  ctx.fillText('High: ' + (parseInt(localStorage.getItem('highScore')) || 0), W - 10, 16);
}

// Game Over Screen
function drawGameOver() {
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = '#fff';
  ctx.font = '20px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('GAME OVER', W/2, H/2 - 20);
  ctx.font = '14px monospace';
  ctx.fillText('Score: ' + score, W/2, H/2 + 5);
  ctx.fillText('Press SPACE to Restart', W/2, H/2 + 30);
}

function restartGame() {
  score = 0; health = 5; ammo = maxAmmo;
  enemies.length = 0; bullets.length = 0; particles.length = 0;
  gameOver = false;
}

// Main Loop
function loop() {
  frame++;
  drawBackground();

  if (!gameOver) {
    // Turrets rotate together
    turrets.forEach(t => {
      if (left) t.angle -= 0.05;
      if (right) t.angle += 0.05;
      t.angle = Math.max(-Math.PI/4, Math.min(Math.PI/4, t.angle));
      t.draw();
    });

    if (bulletCooldown > 0) bulletCooldown--;
    if (shooting && bulletCooldown <= 0) shoot();

    if (reloading) {
      reloadCooldown++;
      if (reloadCooldown >= reloadTime) { ammo = maxAmmo; reloading = false; }
    }

    if (frame % 60 === 0) spawnEnemy();

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx; b.y += b.vy; b.draw();
      if (b.y < -20) bullets.splice(i, 1);
    }

    // Enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      const dx = W/2 - e.x;
      const dy = (H - 40 - e.y);
      const dist = Math.hypot(dx, dy);
      if (dist > 40) {
        const desiredAngle = Math.atan2(dy, dx);
        const desiredVx = Math.cos(desiredAngle) * e.speed;
        const desiredVy = Math.sin(desiredAngle) * e.speed;
        e.vx += (desiredVx - e.vx) * e.homingStrength;
        e.vy += (desiredVy - e.vy) * e.homingStrength;
      }
      e.x += e.vx; e.y += e.vy;
      e.speed = Math.hypot(e.vx, e.vy);
      e.angle = Math.atan2(e.vy, e.vx);
      e.draw();

      // Collision with turrets (same health)
      for (const t of turrets) {
        const turretRadius = 20, enemyRadius = 12;
        const d = Math.hypot(t.x - e.x, t.y - e.y);
        if (d < turretRadius + enemyRadius) {
          spawnExplosion(e.x, e.y, '#ff4444');
          enemies.splice(i, 1);
          health--;
          if (health <= 0) {
            const highScore = parseInt(localStorage.getItem('highScore')) || 0;
            if (score > highScore) localStorage.setItem('highScore', score);
            gameOver = true;
          }
          continue;
        }
      }

      // Bullet collision
      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (Math.hypot(b.x - e.x, b.y - e.y) < 12) {
          bullets.splice(j, 1);
          enemies.splice(i, 1);
          score += 10;
          spawnExplosion(e.x, e.y, '#ffcc44');
          break;
        }
      }

      // Enemy reached ground
      if (e.y > H - 60) {
        spawnExplosion(e.x, e.y, '#ffaa33');
        enemies.splice(i, 1);
        health--;
        if (health <= 0) {
          const highScore = parseInt(localStorage.getItem('highScore')) || 0;
          if (score > highScore) localStorage.setItem('highScore', score);
          gameOver = true;
        }
      }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.life--; p.draw();
      if (p.life <= 0) particles.splice(i, 1);
    }

    drawHUD();
  } else {
    drawGameOver();
  }

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
